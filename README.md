# Data Structure
教务管理系统C++文件系统

*注：编译环境为VC++6.0*


文件 | 说明 | 
------------ | :-------------: | 
Teacher.cpp | 可运行文件  | 
HandedHomeWork| 学生提交的作业  |
Grade.txt|学生成绩及选课情况
HomeWork.txt|教师发布的作业
Tealogin.txt|教师账号及密码
Plagisrist.txt|作业抄袭情况
Unsubmit.txt|未提交作业的情况



 * 学号为20200000的作业存放在HandedHomeWork/20000(课程编号)/20200000(学号).txt
 * Grade.txt内按“
    学号    课程号    平时成绩     期末成绩    总评 
”次序，存放学生成绩及选课情况

## 教师端

已实现的功能：
1. 根据自己的帐号和密码进行登录。登录出错应提示。
2. 发布作业。作业被记录到文件中，供教师与学生查找。
3. 检查作业。统计交作业的情况，统计未提交作业的学生学号以及总人数。 
4. 自动检查抄袭。
比较作业目录下的作业文件，如果有任何两个文件的相似度超过80%，则自动判定为抄袭，向教师提示。
5. 提交课程成绩。
成绩由平时分和期末分的平均得出，其中平时分和期末分由教师输入，计算总评时的比例由老师设置（比如平时分占30％，期末分占70％）。在教师输入了课程成绩之后，教务员端能查找到，学生端也能查找到自己的成绩。实现提示：在输入成绩后，该成绩被记录到文件中，以供查找。

6. 退出保存功能。当该软件被关闭，再打开时，数据没有丢失。

- - - -

## 实现：

### 使用Open Hash存储教师的教师编号与密码。
图中结点的键值“88880001”至“88882000”均为教师编号。考虑到
1. 几乎不注销账号，不经常使用删除操作。
2. 它可以提供快速的插入操作和查找操作。
3. 教师编号唯一，哈希函数设计为教师编号对教师总人数取余，使散列地址分布均匀。很少有冲突情况。

<img src="https://github.com/Mowenyii/-/blob/master/Data_Structure/openhash.jpg" width="25%" height="25%"/>


 * 注册时，
根据教师编号计算出在数组的位置。如果这个位置上没有元素，那么直接将它存储在这个位置上；如果这个位置上已经有元素了，遍历链表，比较教师编号，若有相同（提示用户），若无相同，存在链表尾部。
 * 登录时，
通过哈希函数计算，找到对应链表，再遍历链表，如果输入的教师编号、密码与结点的相匹配，则登陆成功。





### 下面是使用hash表 结合BST存储选课信息以及某个课程的学生成绩。
因为考虑到有两万个学生与200门课程，若使用一张哈希表，可能需要一个**200*2w**这么大的数组，所需要的空间太多。有的课程选课人多、有的课选课人少，可能出现空间没得到有效利用的情况。

    一共有200门课，所以建立一个长度为200的哈希表和200个二叉查找树，
    用200门课的课程编号映射到相应的BST，一棵树存放一门课程的信息，使用选课学生的学号作为二叉查找树的键。


<img src="https://github.com/Mowenyii/-/blob/master/Data_Structure/hash_bst.jpg" width="25%" height="25%"/>


由于学号随机，按学号放使整棵树高度变小。这也有效解决了有的课程选课人多、有的课选课人少情况下，空间的浪费。
当修改同一门课程的平时分占总分比时，可以大批量修改学生成绩。

所以，
 * 插入数据时，先根据课程编号找到在数组的位置。再对BST进行插入。  
 * 查找数据，先根据课程编号找到在数组的位置。再对BST进行查找。
将数据写入txt文档时，是用前序遍历写进去的，也就是按学号“中小大”顺序写入，在下次读取txt建立BST时，就可以避免BST成链的情况。






### 由于需要计算作业相似度，这里使用了最长公共子序列计算两文本的相似度。
如果最长公共子序列长为k，文本1长为n1，文本2长为n2，则相似度为

    (2*k)/(n1+n2)


下面介绍最长公共子序列的实现：

<img src="https://github.com/Mowenyii/-/blob/master/Data_Structure/LCS.jpg" width="60%" height="60%"/>


用二维数组Cmn记录串X与Y的最长公共子序列长度，m、n分别为x、y长度。

1. 当xi=yj时，找出Xi-1和Yj-1的最长公共子序列，然后在其尾部加上xi(或者yj)即可得X和Y的一个最长公共子序列。
2. 当xi≠yj时，必须解两个子问题，即找出Xi和Yj-1的一个最长公共子序列及Xi-1和Yj的一个最长公共子序列。这两个公共子序列中较长者即为X和Y的一个最长公共子序列。

	在算法中，每一次的递归调用使i或j减1，因此算法的计算时间为Θ(m+n)。构建c[m][n]表需要Θ(mn)。
计算出最长公共子序列长为k后，如果文本1长为n1，文本2长为n2，则相似度为   (n1+n2)分之2k。若相似度大于80%，则判为抄袭。

<img src="https://github.com/Mowenyii/-/blob/master/Data_Structure/list.jpg" width="100%" height="70%"/>

这里使用了链表存放学号以及相应的作业。链表的键值为学号。由于需要两两比对，使用两个for循环遍历链表（先确定一个指针，另一个遍历，再移动那个指针）
比对过程，使用最长公共子序列计算每两个学生作业的相似度，如果相似度大于0.8，记录这两位同学的学号。

由于两两比对，使用两个for循环遍历链表、加上使用最长公共子序列计算所需时间较长。考虑到现实生活中，如果第一位与第二位相似度过大，则判定两位都存在抄袭情况，不需要再将第二位与其他同学比较。

*故可以删掉一个相同的，除去重复比较的过程。*


**分析：**

 在选用数据结构时，如果使用哈希表存放学号以及相应的作业。如果使用定长哈希表，由于学生数不确定，开出的数组，容易出现空间的浪费。如果通过new创建哈希表，很难做到刚才说的删除操作。

 若使用BST，BST的一个结点比链表的结点多了一个指针的空间。所以使用链表存放学号以及学生作业。
